"""
Agent de D√©tection Multilingue - Solar Nasih SMA
D√©tecte et traite plusieurs langues pour l'assistance solaire
Supporte: Fran√ßais, Darija, Arabe, Tamazight, Anglais
"""

from typing import Dict, Any, List, Optional
import re
import logging
from datetime import datetime
from agents.base_agent import BaseAgent
from models.schemas import AgentType
from services.gemini_service import GeminiService
from services.tavily_service import TavilyService

logger = logging.getLogger(__name__)

class MultilingualDetectorAgent(BaseAgent):
    """
    Agent de D√©tection Multilingue - D√©tecte et traite plusieurs langues
    Supporte: Fran√ßais, Darija, Arabe, Tamazight, Anglais
    """
    
    def __init__(self):
        super().__init__(
            agent_type=AgentType.MULTILINGUAL_DETECTOR,
            description="Agent de d√©tection et traitement multilingue pour l'√©nergie solaire"
        )
        
        # Services
        self.gemini_service = GeminiService()
        self.tavily_service = TavilyService()
        
        # Langues support√©es avec leurs codes et noms
        self.supported_languages = {
            "fr": {
                "name": "Fran√ßais",
                "native_name": "Fran√ßais",
                "indicators": ["le", "la", "les", "un", "une", "des", "et", "ou", "mais", "pour", "avec", "dans", "sur", "par", "sans", "sous", "je", "tu", "il", "elle", "nous", "vous", "ils", "elles"],
                "solar_terms": ["photovolta√Øque", "solaire", "panneau", "onduleur", "√©lectricit√©", "√©nergie", "installation", "kwh", "kwc"]
            },
            "darija": {
                "name": "Darija",
                "native_name": "ÿßŸÑÿØÿßÿ±ÿ¨ÿ©",
                "indicators": ["ŸÉŸäŸÅÿßÿ¥", "ÿπŸÑÿßÿ¥", "ŸÅŸäŸÜ", "ÿ¥ŸÉŸàŸÜ", "ÿ¥ŸÜŸà", "ŸÅÿßÿ¥", "ÿπÿßŸÅÿßŸÉ", "ÿ≥ŸÑÿßŸÖ", "ÿ¥ŸÉÿ±ÿß", "ÿ®ÿ≤ÿßŸÅ", "Ÿàÿßÿ¥", "ŸÉÿßŸäŸÜ", "ŸÖÿßŸÉÿßŸäŸÜÿ¥", "ÿπŸÜÿØŸä", "ÿπŸÜÿØŸÉ", "ÿπŸÜÿØŸà"],
                "solar_terms": ["ÿ∑ÿßÿ®ŸÑÿ©", "ÿ¥ŸÖÿ≥Ÿäÿ©", "ŸÉŸáÿ±ÿ®ÿßÿ°", "ÿ∑ÿßŸÇÿ©", "ÿ™ÿ±ŸÉŸäÿ®", "ŸÇŸàÿ©", "ŸÉŸäŸÑŸàŸàÿßÿ∑", "ÿ¥ŸÖÿ≥", "ÿ∂Ÿàÿ°"]
            },
            "ar": {
                "name": "Arabe",
                "native_name": "ÿßŸÑÿπÿ±ÿ®Ÿäÿ©",
                "indicators": ["ŸÉŸäŸÅ", "ŸÑŸÖÿßÿ∞ÿß", "ÿ£ŸäŸÜ", "ŸÖŸÜ", "ŸÖÿßÿ∞ÿß", "ŸÖÿ™Ÿâ", "Ÿáÿ∞ÿß", "Ÿáÿ∞Ÿá", "ÿßŸÑÿ™Ÿä", "ÿßŸÑÿ∞Ÿä", "ÿπŸÜÿØŸä", "ÿπŸÜÿØŸÉ", "ÿπŸÜÿØŸá", "ŸÜÿ≠ŸÜ", "ÿ£ŸÜÿ™ŸÖ", "ŸáŸÖ"],
                "solar_terms": ["ŸÑŸàÿ≠ÿ©", "ÿ¥ŸÖÿ≥Ÿäÿ©", "ŸÉŸáÿ±Ÿàÿ∂Ÿàÿ¶Ÿäÿ©", "ÿ∑ÿßŸÇÿ©", "ÿ™ÿ±ŸÉŸäÿ®", "ŸÇŸàÿ©", "ŸÉŸäŸÑŸàŸàÿßÿ∑", "ÿ¥ŸÖÿ≥", "ÿ∂Ÿàÿ°", "ŸÉŸáÿ±ÿ®ÿßÿ°"]
            },
            "tamazight": {
                "name": "Tamazight",
                "native_name": "‚µú‚¥∞‚µé‚¥∞‚µ£‚µâ‚µñ‚µú",
                "indicators": ["‚µé‚¥∞‚µè", "‚µé‚¥∞‚µè‚µâ", "‚µé‚¥∞‚µè‚µâ‚µé", "‚µé‚¥∞‚µè‚µâ‚µé‚µè", "‚µé‚¥∞‚µè‚µâ‚µé‚µè‚µâ", "‚µé‚¥∞‚µè‚µâ‚µé‚µè‚µâ‚µè", "‚µé‚¥∞‚µè‚µâ‚µé‚µè‚µâ‚µè‚µâ", "‚µé‚¥∞‚µè‚µâ‚µé‚µè‚µâ‚µè‚µâ‚µè", "‚µé‚¥∞‚µè‚µâ‚µé‚µè‚µâ‚µè‚µâ‚µè‚µâ", "‚µé‚¥∞‚µè‚µâ‚µé‚µè‚µâ‚µè‚µâ‚µè‚µâ‚µè"],
                "solar_terms": ["‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú‚µâ", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú‚µâ‚µè", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú‚µâ‚µè‚µâ", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú‚µâ‚µè‚µâ‚µè", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú‚µâ‚µè‚µâ‚µè‚µâ", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú‚µâ‚µè‚µâ‚µè‚µâ‚µè", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú‚µâ‚µè‚µâ‚µè‚µâ‚µè‚µâ", "‚µú‚¥∞‚µè‚µô‚µî‚µâ‚µè‚µú‚µâ‚µè‚µâ‚µè‚µâ‚µè‚µâ‚µè"]
            },
            "en": {
                "name": "English",
                "native_name": "English", 
                "indicators": ["the", "and", "is", "are", "was", "were", "with", "for", "but", "or", "in", "on", "at", "by", "I", "you", "he", "she", "it", "we", "they"],
                "solar_terms": ["photovoltaic", "solar", "panel", "inverter", "electricity", "energy", "installation", "kwh", "kwp"]
            }
        }
        
        # R√©ponses types par langue pour l'√©nergie solaire
        self.solar_responses = {
            "fr": {
                "welcome": "üåû Bonjour ! Je suis votre assistant en √©nergie solaire. Comment puis-je vous aider ?",
                "general_info": """
L'√©nergie solaire photovolta√Øque convertit la lumi√®re du soleil en √©lectricit√©.

‚úÖ Avantages principaux :
‚Ä¢ √ânergie renouvelable et gratuite
‚Ä¢ R√©duction de la facture √©lectrique
‚Ä¢ Impact environnemental positif
‚Ä¢ Autonomie √©nerg√©tique

üí° Sujets que je peux traiter :
‚Ä¢ Prix et financement
‚Ä¢ Simulation de production
‚Ä¢ Conseils techniques
‚Ä¢ R√©glementation
‚Ä¢ D√©marches administratives
                """,
                "pricing": "En France, une installation photovolta√Øque co√ªte entre 2000‚Ç¨ et 3000‚Ç¨ par kWc install√©.",
                "simulation": "La production solaire en France varie de 1000 √† 1400 kWh par kWc install√© selon la r√©gion."
            },
            "darija": {
                "welcome": "üåû ÿßŸÑÿ≥ŸÑÿßŸÖ ÿπŸÑŸäŸÉŸÖ ! ÿ£ŸÜÿß ŸÖÿ≥ÿßÿπÿØŸÉŸÖ ŸÅŸä ÿßŸÑÿ∑ÿßŸÇÿ© ÿßŸÑÿ¥ŸÖÿ≥Ÿäÿ©. ŸÉŸäŸÅÿßÿ¥ ŸÜŸÇÿØÿ± ŸÜÿÆÿØŸÖŸÉŸÖ ÿü",
                "general_info": """
ÿßŸÑÿ∑ÿßŸÇÿ© ÿßŸÑÿ¥ŸÖÿ≥Ÿäÿ© ÿßŸÑŸÉŸáÿ±Ÿàÿ∂Ÿàÿ¶Ÿäÿ© ÿ™ÿ≠ŸàŸÑ ÿ∂Ÿàÿ° ÿßŸÑÿ¥ŸÖÿ≥ ÿ•ŸÑŸâ ŸÉŸáÿ±ÿ®ÿßÿ°.

‚úÖ ÿßŸÑŸÖÿ≤ÿßŸäÿß ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© :
‚Ä¢ ÿ∑ÿßŸÇÿ© ŸÖÿ™ÿ¨ÿØÿØÿ© ŸàŸÖÿ¨ÿßŸÜŸäÿ©
‚Ä¢ ÿ™ŸÇŸÑŸäŸÑ ŸÅÿßÿ™Ÿàÿ±ÿ© ÿßŸÑŸÉŸáÿ±ÿ®ÿßÿ°
‚Ä¢ ÿ™ÿ£ÿ´Ÿäÿ± ÿ•Ÿäÿ¨ÿßÿ®Ÿä ÿπŸÑŸâ ÿßŸÑÿ®Ÿäÿ¶ÿ©
‚Ä¢ ÿßÿ≥ÿ™ŸÇŸÑÿßŸÑŸäÿ© ÿ∑ÿßŸÇŸäÿ©

üí° ÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ ÿßŸÑÿ™Ÿä ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿπÿßŸÑÿ¨ÿ™Ÿáÿß :
‚Ä¢ ÿßŸÑÿ£ÿ≥ÿπÿßÿ± ŸàÿßŸÑÿ™ŸÖŸàŸäŸÑ
‚Ä¢ ŸÖÿ≠ÿßŸÉÿßÿ© ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨
‚Ä¢ ÿßŸÑŸÜÿµÿßÿ¶ÿ≠ ÿßŸÑÿ™ŸÇŸÜŸäÿ©
‚Ä¢ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÖÿßÿ™
‚Ä¢ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™ ÿßŸÑÿ•ÿØÿßÿ±Ÿäÿ©
                """,
                "pricing": "ŸÅŸä ŸÅÿ±ŸÜÿ≥ÿßÿå ÿ™ŸÉŸÑŸÅÿ© ÿßŸÑÿ™ÿ±ŸÉŸäÿ® ÿßŸÑŸÉŸáÿ±Ÿàÿ∂Ÿàÿ¶Ÿä ÿ®ŸäŸÜ 2000 Ÿà 3000 ŸäŸàÿ±Ÿà ŸÑŸÉŸÑ ŸÉŸäŸÑŸàŸàÿßÿ∑ ÿ∞ÿ±Ÿàÿ©.",
                "simulation": "ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ ÿßŸÑÿ¥ŸÖÿ≥Ÿä ŸÅŸä ŸÅÿ±ŸÜÿ≥ÿß Ÿäÿ™ÿ±ÿßŸàÿ≠ ŸÖŸÜ 1000 ÿ•ŸÑŸâ 1400 ŸÉŸäŸÑŸàŸàÿßÿ∑ ÿ≥ÿßÿπÿ© ŸÑŸÉŸÑ ŸÉŸäŸÑŸàŸàÿßÿ∑ ÿ∞ÿ±Ÿàÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©."
            },
            "ar": {
                "welcome": "üåû ŸÖÿ±ÿ≠ÿ®ÿßŸã ! ÿ£ŸÜÿß ŸÖÿ≥ÿßÿπÿØŸÉ ŸÅŸä ÿßŸÑÿ∑ÿßŸÇÿ© ÿßŸÑÿ¥ŸÖÿ≥Ÿäÿ©. ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ÿü",
                "general_info": """
ÿßŸÑÿ∑ÿßŸÇÿ© ÿßŸÑÿ¥ŸÖÿ≥Ÿäÿ© ÿßŸÑŸÉŸáÿ±Ÿàÿ∂Ÿàÿ¶Ÿäÿ© ÿ™ÿ≠ŸàŸÑ ÿ∂Ÿàÿ° ÿßŸÑÿ¥ŸÖÿ≥ ÿ•ŸÑŸâ ŸÉŸáÿ±ÿ®ÿßÿ°.

‚úÖ ÿßŸÑŸÖÿ≤ÿßŸäÿß ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© :
‚Ä¢ ÿ∑ÿßŸÇÿ© ŸÖÿ™ÿ¨ÿØÿØÿ© ŸàŸÖÿ¨ÿßŸÜŸäÿ©
‚Ä¢ ÿ™ŸÇŸÑŸäŸÑ ŸÅÿßÿ™Ÿàÿ±ÿ© ÿßŸÑŸÉŸáÿ±ÿ®ÿßÿ°
‚Ä¢ ÿ™ÿ£ÿ´Ÿäÿ± ÿ•Ÿäÿ¨ÿßÿ®Ÿä ÿπŸÑŸâ ÿßŸÑÿ®Ÿäÿ¶ÿ©
‚Ä¢ ÿßÿ≥ÿ™ŸÇŸÑÿßŸÑŸäÿ© ÿ∑ÿßŸÇŸäÿ©

üí° ÿßŸÑŸÖŸàÿßÿ∂Ÿäÿπ ÿßŸÑÿ™Ÿä ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿπÿßŸÑÿ¨ÿ™Ÿáÿß :
‚Ä¢ ÿßŸÑÿ£ÿ≥ÿπÿßÿ± ŸàÿßŸÑÿ™ŸÖŸàŸäŸÑ
‚Ä¢ ŸÖÿ≠ÿßŸÉÿßÿ© ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨
‚Ä¢ ÿßŸÑŸÜÿµÿßÿ¶ÿ≠ ÿßŸÑÿ™ŸÇŸÜŸäÿ©
‚Ä¢ ÿßŸÑÿ™ŸÜÿ∏ŸäŸÖÿßÿ™
‚Ä¢ ÿßŸÑÿ•ÿ¨ÿ±ÿßÿ°ÿßÿ™ ÿßŸÑÿ•ÿØÿßÿ±Ÿäÿ©
                """,
                "pricing": "ŸÅŸä ŸÅÿ±ŸÜÿ≥ÿßÿå ÿ™ŸÉŸÑŸÅÿ© ÿßŸÑÿ™ÿ±ŸÉŸäÿ® ÿßŸÑŸÉŸáÿ±Ÿàÿ∂Ÿàÿ¶Ÿä ÿ®ŸäŸÜ 2000 Ÿà 3000 ŸäŸàÿ±Ÿà ŸÑŸÉŸÑ ŸÉŸäŸÑŸàŸàÿßÿ∑ ÿ∞ÿ±Ÿàÿ©.",
                "simulation": "ÿßŸÑÿ•ŸÜÿ™ÿßÿ¨ ÿßŸÑÿ¥ŸÖÿ≥Ÿä ŸÅŸä ŸÅÿ±ŸÜÿ≥ÿß Ÿäÿ™ÿ±ÿßŸàÿ≠ ŸÖŸÜ 1000 ÿ•ŸÑŸâ 1400 ŸÉŸäŸÑŸàŸàÿßÿ∑ ÿ≥ÿßÿπÿ© ŸÑŸÉŸÑ ŸÉŸäŸÑŸàŸàÿßÿ∑ ÿ∞ÿ±Ÿàÿ© ÿ≠ÿ≥ÿ® ÿßŸÑŸÖŸÜÿ∑ŸÇÿ©."
            },
            "tamazight": {
                "welcome": "üåû ‚¥∞‚µ£‚µç‚µé ‚µé‚µç‚µâ‚¥Ω ! ‚µè‚¥Ω ‚¥∞‚µô‚µô‚µâ‚µô‚µú‚¥∞‚µè ‚µè‚µè‚µâ‚µé ‚¥∞‚µè ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô. ‚µé‚¥∞‚µè ‚µâ‚µç‚µç‚¥∞ ‚µè‚µô‚µô‚µâ‚µî ‚¥∞‚µñ ?",
                "general_info": """
‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µç‚µâ‚µè‚µô‚µî‚µâ ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µô ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô.

‚úÖ ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µç‚µâ‚µè‚µô‚µî‚µâ :
‚Ä¢ ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô
‚Ä¢ ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô
‚Ä¢ ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô
‚Ä¢ ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô
                """,
                "pricing": "‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô.",
                "simulation": "‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô ‚µâ‚µô‚µô‚µâ‚µî ‚µâ‚µé‚µô‚µô‚µâ ‚µè ‚µô‚µâ‚µé‚µô."
            },
            "en": {
                "welcome": "üåû Hello! I'm your solar energy assistant. How can I help you?",
                "general_info": """
Solar photovoltaic energy converts sunlight into electricity.

‚úÖ Main advantages:
‚Ä¢ Renewable and free energy
‚Ä¢ Electricity bill reduction
‚Ä¢ Positive environmental impact
‚Ä¢ Energy independence

üí° Topics I can help with:
‚Ä¢ Pricing and financing
‚Ä¢ Production simulation
‚Ä¢ Technical advice
‚Ä¢ Regulations
‚Ä¢ Administrative procedures
                """,
                "pricing": "In France, a photovoltaic installation costs between ‚Ç¨2000 and ‚Ç¨3000 per kWp installed.",
                "simulation": "Solar production in France varies from 1000 to 1400 kWh per kWp installed depending on the region."
            }
        }
    
    def _init_tools(self) -> List:
        """Initialise les outils de l'agent"""
        return []
    
    def _get_system_prompt(self) -> str:
        """Prompt syst√®me de l'agent multilingue"""
        return """
        Tu es l'Agent de D√©tection Multilingue du syst√®me Solar Nasih.
        
        Tes responsabilit√©s :
        1. D√©tecter automatiquement la langue de l'utilisateur
        2. Traduire les r√©ponses dans la langue de l'utilisateur
        3. Adapter le contenu selon la culture et les habitudes linguistiques
        4. Supporter : Fran√ßais, Darija, Arabe, Tamazight, Anglais
        
        Langues support√©es :
        - Fran√ßais (fr) : Langue principale du syst√®me
        - Darija (darija) : Arabe dialectal marocain
        - Arabe (ar) : Arabe standard
        - Tamazight (tamazight) : Langue berb√®re
        - Anglais (en) : Langue internationale
        
        Tu dois toujours d√©tecter la langue et traduire la r√©ponse finale.
        """
    
    def detect_language(self, text: str) -> Dict[str, Any]:
        """D√©tecte la langue du texte avec plusieurs m√©thodes"""
        try:
            text_lower = text.lower().strip()
            
            if not text_lower:
                return {"language": "fr", "confidence": 0.5, "method": "default"}
            
            # M√©thode 1: D√©tection par patterns
            pattern_result = self._detect_with_patterns(text_lower)
            
            # M√©thode 2: D√©tection par caract√®res
            char_result = self._detect_with_characters(text_lower)
            
            # Combiner les r√©sultats
            combined_lang = self._combine_detection_results(pattern_result, char_result)
            
            logger.info(f"Langue d√©tect√©e: {combined_lang['language']} (confiance: {combined_lang['confidence']})")
            
            return combined_lang
            
        except Exception as e:
            logger.error(f"Erreur d√©tection langue: {e}")
            return {"language": "fr", "confidence": 0.3, "method": "fallback", "error": str(e)}
    
    def _detect_with_patterns(self, text: str) -> Dict[str, Any]:
        """D√©tecte la langue par analyse des mots-cl√©s"""
        scores = {}
        
        for lang_code, lang_data in self.supported_languages.items():
            score = 0
            
            # Points pour les mots-cl√©s g√©n√©raux
            for indicator in lang_data["indicators"]:
                if indicator in text:
                    score += 2
            
            # Points pour les termes solaires
            for term in lang_data["solar_terms"]:
                if term in text:
                    score += 3
            
            # Points bonus pour patterns sp√©cifiques
            if lang_code == "darija":
                darija_patterns = ["ŸÉŸäŸÅÿßÿ¥", "ÿπŸÑÿßÿ¥", "ŸÅŸäŸÜ", "ÿ¥ŸÉŸàŸÜ", "ÿ¥ŸÜŸà", "ŸÅÿßÿ¥", "ÿπÿßŸÅÿßŸÉ", "Ÿàÿßÿ¥", "ŸÉÿßŸäŸÜ", "ŸÖÿßŸÉÿßŸäŸÜÿ¥"]
                for pattern in darija_patterns:
                    if pattern in text:
                        score += 4
            elif lang_code == "ar":
                arabic_patterns = ["ŸÉŸäŸÅ", "ŸÑŸÖÿßÿ∞ÿß", "ÿ£ŸäŸÜ", "ŸÖŸÜ", "ŸÖÿßÿ∞ÿß", "ŸÖÿ™Ÿâ", "Ÿáÿ∞ÿß", "Ÿáÿ∞Ÿá"]
                for pattern in arabic_patterns:
                    if pattern in text:
                        score += 3
            elif lang_code == "tamazight":
                tamazight_patterns = ["‚µé‚¥∞‚µè", "‚µé‚¥∞‚µè‚µâ", "‚µé‚¥∞‚µè‚µâ‚µé", "‚µé‚¥∞‚µè‚µâ‚µé‚µè", "‚µé‚¥∞‚µè‚µâ‚µé‚µè‚µâ"]
                for pattern in tamazight_patterns:
                    if pattern in text:
                        score += 4
            
            scores[lang_code] = score
        
        # Retourner la langue avec le meilleur score
        if scores:
            best_lang = max(scores.items(), key=lambda x: x[1])
            confidence = min(best_lang[1] / 10, 0.95)  # Normaliser la confiance
            return {
                "language": best_lang[0] if best_lang[1] > 0 else "fr",
                "confidence": confidence,
                "method": "patterns"
            }
        
        return {"language": "fr", "confidence": 0.3, "method": "patterns"}
    
    def _detect_with_characters(self, text: str) -> Dict[str, Any]:
        """D√©tecte la langue par analyse des caract√®res"""
        # Compter les caract√®res arabes
        arabic_chars = len(re.findall(r'[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]', text))
        
        # Compter les caract√®res tamazight
        tamazight_chars = len(re.findall(r'[\u2D30-\u2D7F]', text))
        
        # Compter les caract√®res latins
        latin_chars = len(re.findall(r'[a-zA-Z]', text))
        
        total_chars = len(text)
        
        if total_chars == 0:
            return {"language": "fr", "confidence": 0.3, "method": "characters"}
        
        # Calculer les pourcentages
        arabic_ratio = arabic_chars / total_chars
        tamazight_ratio = tamazight_chars / total_chars
        latin_ratio = latin_chars / total_chars
        
        # D√©tecter la langue dominante
        if arabic_ratio > 0.3:
            # Distinguer entre arabe et darija (bas√© sur des patterns sp√©cifiques)
            darija_indicators = ["ŸÉŸäŸÅÿßÿ¥", "ÿπŸÑÿßÿ¥", "ŸÅŸäŸÜ", "ÿ¥ŸÉŸàŸÜ", "ÿ¥ŸÜŸà", "ŸÅÿßÿ¥", "ÿπÿßŸÅÿßŸÉ", "Ÿàÿßÿ¥", "ŸÉÿßŸäŸÜ", "ŸÖÿßŸÉÿßŸäŸÜÿ¥"]
            if any(indicator in text for indicator in darija_indicators):
                return {"language": "darija", "confidence": min(arabic_ratio + 0.2, 0.9), "method": "characters"}
            else:
                return {"language": "ar", "confidence": min(arabic_ratio + 0.1, 0.9), "method": "characters"}
        elif tamazight_ratio > 0.2:
            return {"language": "tamazight", "confidence": min(tamazight_ratio + 0.3, 0.9), "method": "characters"}
        elif latin_ratio > 0.5:
            # Distinguer fran√ßais et anglais
            english_indicators = ["the", "and", "is", "are", "was", "were", "with", "for", "but", "or"]
            french_indicators = ["le", "la", "les", "un", "une", "des", "et", "ou", "mais", "pour"]
            
            english_score = sum(1 for indicator in english_indicators if indicator in text)
            french_score = sum(1 for indicator in french_indicators if indicator in text)
            
            if english_score > french_score:
                return {"language": "en", "confidence": min(latin_ratio + 0.1, 0.9), "method": "characters"}
            else:
                return {"language": "fr", "confidence": min(latin_ratio + 0.1, 0.9), "method": "characters"}
        
        return {"language": "fr", "confidence": 0.3, "method": "characters"}
    
    def _combine_detection_results(self, pattern_result: Dict, char_result: Dict) -> Dict[str, Any]:
        """Combine les r√©sultats des diff√©rentes m√©thodes de d√©tection"""
        pattern_lang = pattern_result["language"]
        char_lang = char_result["language"]
        pattern_conf = pattern_result["confidence"]
        char_conf = char_result["confidence"]
        
        # Si les deux m√©thodes donnent le m√™me r√©sultat
        if pattern_lang == char_lang:
            combined_confidence = (pattern_conf + char_conf) / 2
            return {
                "language": pattern_lang,
                "confidence": combined_confidence,
                "method": "combined"
            }
        
        # Si les r√©sultats diff√®rent, prendre celui avec la plus haute confiance
        if pattern_conf > char_conf:
            return pattern_result
        else:
            return char_result
    
    async def translate_text(self, text: str, source_lang: str, target_lang: str = "fr") -> Dict[str, Any]:
        """Traduit le texte d'une langue vers une autre"""
        try:
            if source_lang == target_lang:
                return {
                    "translated_text": text,
                    "source_language": source_lang,
                    "target_language": target_lang,
                    "confidence": 1.0
                }
            
            # Utiliser Gemini pour la traduction
            llm = self.gemini_service.get_llm()
            
            prompt = f"""
            Traduis le texte suivant de {source_lang} vers {target_lang}.
            Conserve le sens et le style du texte original.
            
            Texte √† traduire: {text}
            
            Traduction en {target_lang}:
            """
            
            response = await llm.ainvoke(prompt)
            translated_text = response.content if hasattr(response, 'content') else str(response)
            
            return {
                "translated_text": translated_text,
                "source_language": source_lang,
                "target_language": target_lang,
                "confidence": 0.8
            }
            
        except Exception as e:
            logger.error(f"Erreur traduction: {e}")
            return {
                "translated_text": text,  # Retourner le texte original en cas d'erreur
                "source_language": source_lang,
                "target_language": target_lang,
                "confidence": 0.3,
                "error": str(e)
            }
    
    def get_solar_response(self, language: str, topic: str = "general_info") -> str:
        """R√©cup√®re une r√©ponse pr√©d√©finie dans la langue sp√©cifi√©e"""
        if language in self.solar_responses and topic in self.solar_responses[language]:
            return self.solar_responses[language][topic]
        else:
            # Fallback vers fran√ßais
            return self.solar_responses["fr"].get(topic, "Information non disponible")
    
    async def process(self, state) -> Dict[str, Any]:
        """M√©thode principale de traitement - d√©tecte la langue et traduit la r√©ponse"""
        try:
            user_message = state.current_message
            
            # 1. D√©tecter la langue de l'utilisateur
            detection_result = self.detect_language(user_message)
            detected_language = detection_result["language"]
            confidence = detection_result["confidence"]
            
            logger.info(f"Langue d√©tect√©e: {detected_language} (confiance: {confidence})")
            
            # 2. Analyser le contenu pour d√©terminer le type de r√©ponse
            topic = self._analyze_solar_topic(user_message)
            
            # 3. G√©n√©rer la r√©ponse dans la langue d√©tect√©e
            if detected_language in self.solar_responses:
                response = self.get_solar_response(detected_language, topic)
            else:
                # Fallback vers fran√ßais
                response = self.get_solar_response("fr", topic)
            
            # 4. Si la langue d√©tect√©e n'est pas le fran√ßais, traduire la r√©ponse
            if detected_language != "fr":
                translation_result = await self.translate_text(response, "fr", detected_language)
                response = translation_result["translated_text"]
            
            return {
                "response": response,
                "detected_language": detected_language,
                "confidence": confidence,
                "agent_used": "multilingual_detector",
                "sources": ["Solar Nasih Multilingual Detection"],
                "translation_info": {
                    "original_language": "fr",
                    "target_language": detected_language,
                    "translation_confidence": confidence
                }
            }
            
        except Exception as e:
            logger.error(f"Erreur dans l'agent multilingue: {e}")
            return {
                "response": f"Erreur dans le traitement multilingue: {str(e)}",
                "detected_language": "fr",
                "confidence": 0.0,
                "agent_used": "multilingual_detector",
                "error": str(e),
                "sources": ["Solar Nasih Multilingual Detection"]
            }
    
    def _analyze_solar_topic(self, message: str) -> str:
        """Analyse le message pour d√©terminer le sujet solaire"""
        message_lower = message.lower()
        
        if any(word in message_lower for word in ["prix", "co√ªt", "tarif", "price", "cost", "ÿ≥ÿπÿ±", "ÿ´ŸÖŸÜ", "‚µô‚µâ‚µî"]):
            return "pricing"
        elif any(word in message_lower for word in ["simulation", "production", "kwh", "kwc", "ŸÖÿ≠ÿßŸÉÿßÿ©", "ÿ•ŸÜÿ™ÿßÿ¨", "‚µâ‚µô‚µô‚µâ‚µî"]):
            return "simulation"
        elif any(word in message_lower for word in ["bonjour", "salut", "hello", "ŸÖÿ±ÿ≠ÿ®ÿß", "ÿ≥ŸÑÿßŸÖ", "‚¥∞‚µ£‚µç‚µé"]):
            return "welcome"
        else:
            return "general_info"
    
    def can_handle(self, user_input: str, context: Dict[str, Any] = None) -> float:
        """D√©termine si l'agent peut traiter la requ√™te"""
        # L'agent multilingue peut traiter toutes les requ√™tes
        # mais avec une priorit√© plus √©lev√©e pour les langues non-fran√ßaises
        text_lower = user_input.lower()
        
        # D√©tecter si le texte contient des caract√®res non-latins
        has_arabic = bool(re.search(r'[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]', text_lower))
        has_tamazight = bool(re.search(r'[\u2D30-\u2D7F]', text_lower))
        
        if has_arabic or has_tamazight:
            return 0.9  # Haute priorit√© pour les langues non-latines
        
        # V√©rifier les mots-cl√©s sp√©cifiques
        multilingual_indicators = [
            "ŸÉŸäŸÅÿßÿ¥", "ÿπŸÑÿßÿ¥", "ŸÅŸäŸÜ", "ÿ¥ŸÉŸàŸÜ", "ÿ¥ŸÜŸà", "ŸÅÿßÿ¥", "ÿπÿßŸÅÿßŸÉ",  # Darija
            "ŸÉŸäŸÅ", "ŸÑŸÖÿßÿ∞ÿß", "ÿ£ŸäŸÜ", "ŸÖŸÜ", "ŸÖÿßÿ∞ÿß", "ŸÖÿ™Ÿâ",  # Arabe
            "‚µé‚¥∞‚µè", "‚µé‚¥∞‚µè‚µâ", "‚µé‚¥∞‚µè‚µâ‚µé",  # Tamazight
            "the", "and", "is", "are", "was", "were"  # Anglais
        ]
        
        if any(indicator in text_lower for indicator in multilingual_indicators):
            return 0.8
        
        return 0.3  # Priorit√© normale pour le fran√ßais 